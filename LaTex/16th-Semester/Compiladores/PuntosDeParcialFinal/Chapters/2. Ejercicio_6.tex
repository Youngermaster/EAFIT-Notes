\section{Ejercicio 6 [20 pts]}

\subsection{Enunciado}

Diseñe un transductor sequencial determinista $M$ que lea cadenas sobre $\Sigma = \{0, 1\}$ y produzca como salida la complementaria de cada bit ($0 \rightarrow 1, 1 \rightarrow 0$); por ejemplo, si la entrada es $10110$, entonces la salida debe ser $01001$. Adicionalmente, dibuje el diagrama de estados del transductor y especifique formalmente las funciones de transición $\delta$ y de salida $\eta$.

\subsection{Análisis y Diseño}
El objetivo es diseñar un transductor secuencial determinista que calcule el complemento a 1 de la entrada (intercambiar 0s y 1s). Prácticamente en resumen el problema solicita calcular el complemento a 1 bit a bit.
\begin{itemize}
    \item \textbf{Análisis de Memoria:} Para decidir la salida de un bit actual, ¿necesitamos recordar el bit anterior? No. La transformación de $0 \to 1$ y $1 \to 0$ es independiente del contexto histórico de la cadena.
    \item \textbf{Conclusión:} Dado que no se requiere memoria (contexto), el autómata solo necesita un único estado ($q_0$) que actúe como bucle perpetuo procesando la entrada símbolo a símbolo. Esto garantiza que el transductor sea \textit{determinista} y \textit{secuencial} \cite{crespi2019formal}.
\end{itemize}

\subsection{Especificación Formal}
El transductor se define como la tupla $M = (Q, \Sigma, \Delta, \delta, \eta, \varphi, q_0, F)$, siguiendo la definición formal de autómatas con salida \cite{kozen1997automata}, donde:

\begin{itemize}
    \item $Q = \{q_0\}$ (conjunto de estados)
    \item $\Sigma = \{0, 1\}$ (alfabeto de origen)
    \item $\Delta = \{0, 1\}$ (alfabeto de destino)
    \item $F = \{q_0\}$ (conjunto de estados de aceptación)
\end{itemize}

\subsubsection*{Definición de Funciones}
\begin{enumerate}
    \item \textbf{Función de transición} ($\delta: Q \times \Sigma \to Q$): El autómata permanece en el mismo estado.
    \[ \delta(q_0, 0) = q_0, \quad \delta(q_0, 1) = q_0 \]
    Siempre regresamos al mismo estado para procesar el siguiente bit.
    
    \item \textbf{Función de salida} ($\eta: Q \times \Sigma \to \Delta^*$): Emite el bit complementario.
    \[ \eta(q_0, 0) = 1, \quad \eta(q_0, 1) = 0 \]
    Aquí reside la lógica del complemento: si leemos 0 escribimos 1, y viceversa.
    
    \item \textbf{Función final} ($\varphi: F \times \{\dashv\} \to \Delta^*$): No se emite nada al terminar la cadena.
    \[ \varphi(q_0, \dashv) = \epsilon \]
    Al terminar la cadena, no hay bits pendientes ni operaciones de cierre (como acarreos), por lo que la salida final es vacía.
\end{enumerate}

\subsection{Diagrama de Estados}
El diagrama de transición de estados es entonces:

\begin{center}
\begin{tikzpicture}[shorten >=1pt, node distance=3.5cm, on grid, auto] 
   \node[state, initial, accepting] (q_0)   {$q_0$}; 
   
   \path[->] 
    (q_0) edge [loop above] node {$\frac{0}{1}$} ()
          edge [loop below] node {$\frac{1}{0}$} ()
          edge [loop right] node [yshift=-1em] {$\frac{\dashv}{\epsilon}$} (); % Representación visual de la función final (opcional pero clara)
\end{tikzpicture}
\end{center}

\subsection{Verificación (Traza de ejecución)}
Para verificar la corrección, procesamos la cadena de ejemplo $w = 10110$:

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|l}
\toprule
\textbf{Estado} & \textbf{Entrada} & \textbf{Salida ($\eta$)} & \textbf{Descripción} \\
\midrule
$q_0$ & 1 & 0 & Lectura de 1, complemento 0 \\
$q_0$ & 0 & 1 & Lectura de 0, complemento 1 \\
$q_0$ & 1 & 0 & Lectura de 1, complemento 0 \\
$q_0$ & 1 & 0 & Lectura de 1, complemento 0 \\
$q_0$ & 0 & 1 & Lectura de 0, complemento 1 \\
$q_0$ & $\dashv$ & $\epsilon$ & Fin de cadena ($\varphi$) \\
\midrule
\multicolumn{2}{r|}{\textbf{Resultado Final:}} & \textbf{01001} & \\
\bottomrule
\end{tabular}
\caption{Traza paso a paso para la entrada 10110}
\end{table}