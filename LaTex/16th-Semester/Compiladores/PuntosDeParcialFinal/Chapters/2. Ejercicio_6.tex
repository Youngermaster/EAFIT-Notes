\section{Ejercicio 6 [20 pts]}

Diseñe un transductor sequencial determinista $M$ que lea cadenas sobre $\Sigma = \{0, 1\}$ y produzca como salida la complementaria de cada bit ($0 \rightarrow 1, 1 \rightarrow 0$); por ejemplo, si la entrada es $10110$, entonces la salida debe ser $01001$. Adicionalmente, dibuje el diagrama de estados del transductor y especifique formalmente las funciones de transición $\delta$ y de salida $\eta$.

\section{Desarrollo Ejercicio 6}

\subsection{Análisis y Diseño}
El objetivo es diseñar un transductor secuencial determinista que calcule el complemento a 1 de la entrada (intercambiar 0s y 1s). Prácticamente en resumen el problema solicita calcular el complemento a 1 bit a bit.
\begin{itemize}
    \item \textbf{Análisis de Memoria:} Para decidir la salida de un bit actual, ¿necesitamos recordar el bit anterior? No. La transformación de $0 \to 1$ y $1 \to 0$ es independiente del contexto histórico de la cadena.
    \item \textbf{Conclusión:} Dado que no se requiere memoria (contexto), el autómata solo necesita un único estado ($q_0$) que actúe como bucle perpetuo procesando la entrada símbolo a símbolo. Esto garantiza que el transductor sea \textit{determinista} y \textit{secuencial} \cite{crespi2019formal}.
\end{itemize}

\subsection{Especificación Formal}
El transductor se define como la tupla $M = (Q, \Sigma, \Delta, q_0, F, \delta, \eta, \varphi)$, siguiendo la definición formal de autómatas con salida \cite{kozen1997automata}, donde:

\begin{itemize}
    \item $Q = \{q_0\}$ (Un único estado funcional).
    \item $\Sigma = \{0, 1\}$ (Entrada), $\Delta = \{0, 1\}$ (Salida).
    \item $F = \{q_0\}$ (El estado es final porque cualquier prefijo es válido).
\end{itemize}

\subsubsection*{Definición de Funciones}
\begin{enumerate}
    \item \textbf{Función de transición} ($\delta: Q \times \Sigma \to Q$): El autómata permanece en el mismo estado.
    \[ \delta(q_0, 0) = q_0, \quad \delta(q_0, 1) = q_0 \]
    Siempre regresamos al mismo estado para procesar el siguiente bit.
    
    \item \textbf{Función de salida} ($\eta: Q \times \Sigma \to \Delta^*$): Emite el bit complementario.
    \[ \eta(q_0, 0) = 1, \quad \eta(q_0, 1) = 0 \]
    Aquí reside la lógica del complemento: si leemos 0 escribimos 1, y viceversa.
    
    \item \textbf{Función final} ($\varphi: F \times \{\dashv\} \to \Delta^*$): No se emite nada al terminar la cadena.
    \[ \varphi(q_0, \dashv) = \epsilon \]
    Al terminar la cadena, no hay bits pendientes ni operaciones de cierre (como acarreos), por lo que la salida final es vacía.
\end{enumerate}

\subsection{Diagrama de Estados}
El diagrama de transición de estados es entonces:

\begin{center}
\begin{tikzpicture}[shorten >=1pt,node distance=3cm,on grid,auto] 
   \node[state, initial, accepting] (q_0)   {$q_0$}; 
   \path[->] 
    (q_0) edge [loop above] node {0 / 1} ()
          edge [loop below] node {1 / 0} ();
\end{tikzpicture}
\end{center}

\subsection{Verificación (Traza)}
Probamos el diseño con la cadena de ejemplo del enunciado: $w = 10110$.

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c}
\toprule
\textbf{Estado Actual} & \textbf{Entrada Leída} & \textbf{Salida Generada ($\eta$)} & \textbf{Siguiente Estado ($\delta$)} \\
\midrule
$q_0$ & 1 & 0 & $q_0$ \\
$q_0$ & 0 & 1 & $q_0$ \\
$q_0$ & 1 & 0 & $q_0$ \\
$q_0$ & 1 & 0 & $q_0$ \\
$q_0$ & 0 & 1 & $q_0$ \\
\midrule
\multicolumn{2}{r|}{\textbf{Salida Total:}} & \textbf{01001} & \\
\bottomrule
\end{tabular}
\caption{Traza de ejecución para la entrada 10110}
\end{table}
La salida obtenida $01001$ coincide con el complemento a 1 solicitado.
